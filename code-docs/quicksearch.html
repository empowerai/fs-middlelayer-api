<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"validate.js.html":{"id":"validate.js.html","title":"Source: validate.js","body":" US Forest Service ePermit Middlelayer API Global combinePropArgumenthandleAnyOfErrormakeAnyOfMessagemakeErrorObjremoveInstance Source: validate.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const include = require('include')(__dirname); const Validator = require('jsonschema').Validator; const v = new Validator(); //******************************************************************* const util = include('controllers/permits/applications/special-uses/utility.js'); const schema = require('./validationSchema.json'); //******************************************************************* // schemas const tempOutfitterSchema = schema.tempOutfitterApplication; const tempOutfitterApplicantInfo = schema.tempOutfitterApplicantInfo; const tempOutfitterFields = schema.tempOutfitterFields; const noncommercialSchema = schema.noncommercial; const applicantInfoNoncommercial = schema.noncommercialApplicantInfo; const noncommercialFields = schema.noncommercialFields; const phoneNumber = schema.phoneNumber; const applicantInfoBase = schema.applicantInfoBase; const extraFieldsBase = schema.extraFieldsBase; const commonFields = schema.commonFields; const fileMimes = ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'text/rtf', 'application/pdf']; //******************************************************************* function digitCheck(input, num){ let valid = true; if (typeof input === 'number'){ const inputStr = input + ''; if (!inputStr.match(new RegExp(`^[0-9]{${num}}$`))){ valid = false; } } return valid; } function areaCodeFormat(input){ return digitCheck(input, 3); } function phoneNumberFormat(input){ return digitCheck(input, 7); } //******************************************************************* /** * Removes 'instance' from prop field of validation errors. Used to make fields human readable * * @param {string} prop - Prop field from validation error * @return {string} */ function removeInstance(prop){ let fixedProp = ''; if (prop.indexOf('.') !== -1){ fixedProp = prop.substring((prop.indexOf('.') + 1), (prop.length)); } return fixedProp; } /** * Combines property and argument fields, if property exists, for missing field errors * * @param {string} * @param {string} * @return {string} */ function combinePropArgument(property, argument){ let field; if (property.length &gt; 0){ field = `${property}.${argument}`; } else { field = argument; } return field; } /** * Creates error object which can be read by error message building function * * @param {string} field * @param {string} errorType * @param {string} expectedFieldType * @param {string} enumMessage * @param {string} dependency * @param {string|string[]} anyOfFields * * @return Error object */ function makeErrorObj(field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields){ return { field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields }; } function missingSuperFields(output, field, route){ const applicantInfo = ['applicantInfo.firstName', 'applicantInfo.lastName', 'applicantInfo.dayPhone.areaCode', 'applicantInfo.dayPhone.number', 'applicantInfo.dayPhone.type', 'applicantInfo.emailAddress', 'applicantInfo.mailingAddress', 'applicantInfo.mailingCity', 'applicantInfo.mailingZIP', 'applicantInfo.mailingState']; if (route === 'tempOutfitters'){ applicantInfo.push('applicantInfo.orgType'); } const phone = ['applicantInfo.dayPhone.areaCode', 'applicantInfo.dayPhone.number', 'applicantInfo.dayPhone.type']; const noncommercial = ['noncommercialFields.activityDescription', 'noncommercialFields.locationDescription', 'noncommercialFields.startDateTime', 'noncommercialFields.endDateTime', 'noncommercialFields.numberParticipants']; const tempOutfitter = ['tempOutfitterFields.activityDescription', 'tempOutfitterFields.clientCharges']; if (field === 'applicantInfo'){ applicantInfo.forEach((missingField)=&gt;{ output.errorArray.push(makeErrorObj(missingField, 'missing')); }); } else if (field === 'applicantInfo.dayPhone'){ phone.forEach((missingField)=&gt;{ output.errorArray.push(makeErrorObj(missingField, 'missing')); }); } else if (field === 'noncommercialFields'){ noncommercial.forEach((missingField)=&gt;{ output.errorArray.push(makeErrorObj(missingField, 'missing')); }); } else { tempOutfitter.forEach((missingField)=&gt;{ output.errorArray.push(makeErrorObj(missingField, 'missing')); }); } } function handleMissingError(output, result, counter, route){ const property = removeInstance(result[counter].property); const field = combinePropArgument(property, result[counter].argument); switch (field){ case 'applicantInfo': case 'applicantInfo.dayPhone': case 'noncommercialFields': case 'tempOutfitterFields': missingSuperFields(output, field, route); break; default: output.errorArray.push(makeErrorObj(field, 'missing')); break; } } function handleTypeError(output, result, counter){ const expectedType = result[counter].argument[0]; const property = removeInstance(result[counter].property); output.errorArray.push(makeErrorObj(property, 'type', expectedType)); } function handleFormatError(output, result, counter){ const field = `${removeInstance(result[counter].property)}`; output.errorArray.push(makeErrorObj(field, 'format')); } function handleEnumError(output, result, counter){ const property = removeInstance(result[counter].property); output.errorArray.push(makeErrorObj(property, 'enum', null, result[counter].message)); } function getDependency(result, counter){ const stackMessage = result[counter].stack; const dependency = stackMessage.split(' property ')[1].split(' not ')[0]; return dependency; } function handleDependencyError(output, result, counter){ const error = result[counter]; const dependentField = removeInstance(error.argument); const schemaPath = removeInstance(error.property); const dependency = `${schemaPath}.${getDependency(result, counter)}`; output.errorArray.push(makeErrorObj(dependentField, 'dependencies', null, null, dependency)); } /** * Creates error object for errors resulting from an anyOf section of the validation schema * * @param {object} errorTracking - Error object containing all error to report and the error message to deliver. * @param {array} errorTracking.errorArray - Array contain all errors to report to user. * @param {array} result - Array of errors found during validation. * @param {integer} counter - Position in result that the current error being handled is. * * @affects errorTracking.errorArray */ function handleAnyOfError(errorTracking, result, counter){ const error = result[counter]; const property = removeInstance(error.property); const requiredOptions = []; error.schema.anyOf.forEach((fieldObj)=&gt;{ requiredOptions.push(combinePropArgument(property, fieldObj.required[0])); }); errorTracking.errorArray.push(makeErrorObj(null, 'anyOf', null, null, null, requiredOptions)); } const validateInput = function (route, inputPost){ inputPost = inputPost.body; if (inputPost.body) { inputPost = JSON.parse(inputPost.body); } const errorTracking = { 'fieldsValid': true, 'errorMessage': '', 'errorArray':[] }; let result, counter; v.customFormats.areaCodeFormat = areaCodeFormat; v.customFormats.phoneNumberFormat = phoneNumberFormat; v.addSchema(phoneNumber, 'phoneNumber'); v.addSchema(applicantInfoBase, 'applicantInfoBase'); v.addSchema(applicantInfoNoncommercial, 'applicantInfoNoncommercial'); v.addSchema(noncommercialFields, 'noncommercialFields'); v.addSchema(tempOutfitterApplicantInfo, 'tempOutfitterApplicantInfo'); v.addSchema(tempOutfitterFields, 'tempOutfitterFields'); v.addSchema(extraFieldsBase, 'extraFieldsBase'); v.addSchema(commonFields, 'commonFields'); if (route === 'noncommercial'){ result = v.validate(inputPost, noncommercialSchema).errors; } else { result = v.validate(inputPost, tempOutfitterSchema).errors; } const length = result.length; if (length &gt; 0){ errorTracking.fieldsValid = false; } for (counter = 0; counter &lt; length; counter++){ if (result[counter].name === 'required'){ handleMissingError(errorTracking, result, counter, route); } else if (result[counter].name === 'type'){ handleTypeError(errorTracking, result, counter); } else if (result[counter].name === 'format' || result[counter].name === 'pattern'){ handleFormatError(errorTracking, result, counter); } else if (result[counter].name === 'enum'){ handleEnumError(errorTracking, result, counter); } else if (result[counter].name === 'dependencies'){ handleDependencyError(errorTracking, result, counter); } else if (result[counter].name === 'anyOf'){ handleAnyOfError(errorTracking, result, counter); } } errorTracking.errorMessage = util.buildErrorMessage(errorTracking); const output = { 'success': errorTracking.fieldsValid, 'errorMessage': errorTracking.errorMessage, 'errors': errorTracking.errorArray }; return output; }; const validateFile = function (uploadFile){ let returnError = ''; const regex = '(rtf|doc|docx|pdf)'; const tempErrors = []; tempErrors.push(uploadFile.filetype + ' file errors:'); if (uploadFile.ext &amp;&amp; !uploadFile.ext.toLowerCase().match(regex)){ tempErrors.push('invalid extension,'); } else if (fileMimes.indexOf(uploadFile.mimetype) &lt; 0){ tempErrors.push('invalid mimetype,'); } if (uploadFile.size === 0){ tempErrors.push('size of 0 bytes,'); } else { const fileSizeInMegabytes = uploadFile.size / 1000000.0; if (fileSizeInMegabytes &gt; 100){ tempErrors.push('size is greater than 100 MB,'); } } if (tempErrors.length &gt; 1){ returnError = util.concatErrors(tempErrors); returnError = returnError.trim().replace(/.$/, '.'); } return returnError; }; //******************************************************************* // exports module.exports.validateInput = validateInput; module.exports.validateFile = validateFile; × Search results Close Documentation generated by JSDoc 3.4.3 on April 10, 2017 using the DocStrap template. "},"utility.js.html":{"id":"utility.js.html","title":"Source: utility.js","body":" US Forest Service ePermit Middlelayer API Global combinePropArgumenthandleAnyOfErrormakeAnyOfMessagemakeErrorObjremoveInstance Source: utility.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const jsf = require('json-schema-faker'); const include = require('include')(__dirname); const path = require('path'); const AWS = require('aws-sdk'); const errors = require('./patternErrorMessages.json'); const async = require('async'); //************************************************************* // AWS const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID; const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY; const AWS_REGION = process.env.AWS_REGION; const AWS_BUCKET_NAME = process.env.AWS_BUCKET_NAME; AWS.config.update({ accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY, region: AWS_REGION }); const s3 = new AWS.S3(); //******************************************************************* function makeFieldReadable(input){ return input .replace(/([A-Z])/g, ' $1') .replace(/^./, function(str){ return str.toUpperCase(); }) .replace('Z I P', 'Zip') .replace('U R L', 'URL'); } function makePathReadable(input){ if (typeof input === 'string'){ const parts = input.split('.'); const readableParts = []; let readablePath = ''; parts.forEach((field)=&gt;{ readableParts.push(makeFieldReadable(field)); }); readablePath = readableParts.shift(); readableParts.forEach((part)=&gt;{ readablePath = `${readablePath}/${part}`; }); return readablePath; } else { return false; } } function buildFormatErrorMessage(fullPath){ const field = fullPath.substring(fullPath.lastIndexOf('.') + 1); const readablePath = makePathReadable(fullPath); const errorMessage = `${readablePath}${errors[field]}`; return errorMessage; } /** * Creates error message for anyOf errors * * @param {string|string[]} anyOfFields - list of fields, at least one being required. * @return {string} */ function makeAnyOfMessage(anyOfFields){ if (anyOfFields){ let output, count = 1; const length = anyOfFields.length; output = `${makePathReadable(anyOfFields[0])}`; while (count &lt; length) { const field = anyOfFields[count]; output = `${output} or ${makePathReadable(field)}`; count ++; } return output; } else { return false; } } function concatErrors(errorMessages){ let output = ''; errorMessages.forEach((message)=&gt;{ output = `${output}${message} `; }); output = output.trim(); return output; } function buildErrorMessage(output){ let errorMessage = ''; const messages = []; output.errorArray.forEach((error)=&gt;{ const missing = `${makePathReadable(error.field)} is a required field.`; const type = `${makePathReadable(error.field)} is expected to be type '${error.expectedFieldType}'.`; const enumMessage = `${makePathReadable(error.field)} ${error.enumMessage}.`; const dependencies = `Having ${makePathReadable(error.field)} requires that ${makePathReadable(error.dependency)} be provided.`; const anyOf = `Either ${makeAnyOfMessage(error.anyOfFields)} is a required field.`; switch (error.errorType){ case 'missing': messages.push(missing); break; case 'type': messages.push(type); break; case 'format': case 'pattern': messages.push(buildFormatErrorMessage(error.field)); break; case 'enum': messages.push(enumMessage); break; case 'dependencies': messages.push(dependencies); break; case 'anyOf': messages.push(anyOf); break; } }); errorMessage = concatErrors(messages); return errorMessage; } const pad = function (n) { return ('0' + n).slice(-2); }; const generatePurpose = function (activityDescription, locationDescription, startDateTime, endDateTime){ let purpose = ''; if (activityDescription){ purpose = purpose + activityDescription + ' ' ; } if (locationDescription){ purpose = purpose + locationDescription + ' '; } if (startDateTime){ purpose = purpose + startDateTime + ' '; } if (endDateTime){ purpose = purpose + endDateTime + ' '; } purpose = purpose.trim(); return purpose; }; function fromAdminOrg(cnData, postSchema, jsonData, key){ const adminOrg = cnData[postSchema.adminOrg.intake]; switch (key){ case 'region': jsonData[key] = adminOrg.slice(0, 2); break; case 'forest': jsonData[key] = adminOrg.slice(2, 4); break; case 'district': jsonData[key] = adminOrg.slice(4, 6); break; } } function getTopLevelField(intakeField, cnData, postSchema, jsonData, key){ switch (intakeField){ case 'none': break; case 'fromAdminOrg': fromAdminOrg(cnData, postSchema, jsonData, key); break; default: if (cnData.hasOwnProperty(postSchema[key].intake)){ jsonData[key] = cnData[postSchema[key].intake]; } } } function getSubLevelField(cnData, postSchema, key, jsonData){ const addressData = cnData.addresses[0]; const phoneData = cnData.phones[0]; const holderData = cnData.holders[0]; const path = postSchema[key].intake.split('/'); let data; switch (path[0]){ case 'holders': data = holderData; break; case 'phones': data = phoneData; break; case 'addresses': data = addressData; break; } if (data.hasOwnProperty(path[1])){ jsonData[key] = data[path[1]]; } } function buildGetResponse(cnData, applicationData, schemaData, jsonData, postSchema){ let key; for (key in schemaData){ if (typeof jsonData[key] !== 'object'){ const intakeField = postSchema[key].intake; if (intakeField.startsWith('middleLayer/')){ const applicationField = intakeField.split('/')[1]; jsonData[key] = applicationData[applicationField]; } else { if (intakeField.indexOf('/') === -1){ getTopLevelField(intakeField, cnData, postSchema, jsonData, key); } else { getSubLevelField(cnData, postSchema, key, jsonData); } } } else { buildGetResponse(cnData, applicationData, schemaData[key], jsonData[key], postSchema[key]); } } } function copyGenericInfo(cnData, applicationData, jsonData){ const postSchema = include('controllers/permits/applications/special-uses/getSchema.json'); jsf.option({useDefaultValue:true}); const schemaData = jsf(postSchema); delete schemaData.id; jsonData = schemaData; buildGetResponse(cnData, applicationData, schemaData, jsonData, postSchema); /* Lock down all fields expected to be returned */ return jsonData; } function autoPopulatedFields(postData, inputPost){ let combId = '', purpose; combId = pad(inputPost.region); combId = combId + pad(inputPost.forest); combId = combId + pad(inputPost.district); postData.securityId = combId; postData.managingOrg = combId; postData.adminOrg = combId; const todayDate = new Date().toISOString().slice(0, 10); postData.effectiveDate = todayDate; if (inputPost.applicantInfo.organizationName){ postData.applicantInfo.contactType = 'ORGANIZATION'; } else { postData.applicantInfo.contactType = 'PERSON'; } if (postData.applicantInfo.contactType === 'ORGANIZATION'){ postData.applicantInfo.contName = inputPost.applicantInfo.organizationName; } else { postData.applicantInfo.contName = inputPost.applicantInfo.firstName + ' ' + inputPost.applicantInfo.lastName; } if (inputPost.type === 'noncommercial'){ postData.type = 'noncommercial'; purpose = generatePurpose (postData.noncommercialFields.activityDescription, postData.noncommercialFields.locationDescription, postData.noncommercialFields.startDateTime, postData.noncommercialFields.endDateTime); postData.noncommercialFields.purpose = purpose; delete postData.tempOutfitterFields; } else if (inputPost.type === 'tempOutfitters'){ postData.type = 'tempOutfitters'; purpose = generatePurpose (postData.tempOutfitterFields.activityDescription, postData.tempOutfitterFields.locationDescription, postData.tempOutfitterFields.startDateTime, postData.tempOutfitterFields.endDateTime); postData.tempOutfitterFields.purpose = purpose; delete postData.noncommercialFields; } delete postData.id; } function populatePostData(inputPost, postData, schemaData){ let fieldKey = ''; for (fieldKey in schemaData){ if (inputPost.hasOwnProperty(fieldKey)){ if (typeof inputPost[fieldKey] !== 'object'){ postData[fieldKey] = inputPost[fieldKey]; } else { populatePostData(inputPost[fieldKey], postData[fieldKey], schemaData[fieldKey]); } } } } function createPost(controlNumber, inputPost){ const postSchema = include('controllers/permits/applications/special-uses/postSchema.json'); jsf.option({useDefaultValue:true}); const schemaData = jsf(postSchema); const postData = schemaData; if (inputPost.body) { inputPost = JSON.parse(inputPost.body); } populatePostData(inputPost, postData, schemaData); autoPopulatedFields(postData, inputPost); return postData; } function uploadFiles(controlNumber, files, callback){ const asyncTasks = []; files.forEach(function(file){ asyncTasks.push(function(callback){ const params = { Bucket: AWS_BUCKET_NAME, Key: file.keyname, Body: file.buffer, ACL: 'private' }; s3.putObject(params, function(err, data) { if (err) { console.error(err, err.stack); return callback(err, null); } else { return callback(null, data); } }); }); }); async.parallel(asyncTasks, function(err, data){ if (err){ return callback(err, null); } else { return callback(null, data); } }); } //******************************************************************* // exports module.exports.buildErrorMessage = buildErrorMessage; module.exports.concatErrors = concatErrors; module.exports.copyGenericInfo = copyGenericInfo; module.exports.createPost = createPost; module.exports.uploadFiles = uploadFiles; × Search results Close Documentation generated by JSDoc 3.4.3 on April 10, 2017 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" US Forest Service ePermit Middlelayer API Global combinePropArgumenthandleAnyOfErrormakeAnyOfMessagemakeErrorObjremoveInstance Global Methods combinePropArgument(property, argument) Combines property and argument fields, if property exists, for missing field errors Parameters: Name Type Description property string argument string Source: validate.js, line 106 Returns: Type string handleAnyOfError(errorTracking, result, counter) Creates error object for errors resulting from an anyOf section of the validation schema Parameters: Name Type Description errorTracking object Error object containing all error to report and the error message to deliver. Properties Name Type Description errorArray array Array contain all errors to report to user. result array Array of errors found during validation. counter integer Position in result that the current error being handled is. Source: validate.js, line 261 makeAnyOfMessage(anyOfFields) Creates error message for anyOf errors Parameters: Name Type Description anyOfFields string | Array.&lt;string&gt; list of fields, at least one being required. Source: utility.js, line 89 Returns: Type string makeErrorObj(field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields) Creates error object which can be read by error message building function Parameters: Name Type Description field string errorType string expectedFieldType string enumMessage string dependency string anyOfFields string | Array.&lt;string&gt; Source: validate.js, line 135 Returns: Error object removeInstance(prop) Removes 'instance' from prop field of validation errors. Used to make fields human readable Parameters: Name Type Description prop string Prop field from validation error Source: validate.js, line 85 Returns: Type string × Search results Close Documentation generated by JSDoc 3.4.3 on April 10, 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" US Forest Service ePermit Middlelayer API Global combinePropArgumenthandleAnyOfErrormakeAnyOfMessagemakeErrorObjremoveInstance US Forest Service ePermit Middlelayer APIA repository for the development of an API to support the public facing ePermit system to connect to the related Forest Service database, the Special Use Data System (SUDS) located in the National Resource Management System. This repository is being development under a task order of the Agile Blanket Purchase Agreement. Setup Clone or download this repository. Run npm install to install application and all dependencies. Run npm start to start Node.js server. How to Test Scripts Use npm test to run Mocha unit tests. Use npm run coverage for Istanbul code coverage. Results in /coverage folder. Use npm run lint for ESLint static code analysis. Results in /lint folder. Use npm run fix for ESLint code fix. Use npm run dba to run Sequelize migration and seeder. Use npm run doc to run JSDoc code documentation. Results in /code-docs folder. Data Files: Test files are stored in test/data directory Accounts: Test accounts are stored in environment variables ADMINROLE_USER, ADMINROLE_PWD, ADMINROLE_HASH USERROLE_USER, USERROLE_PWD, USERROLE_HASH Configuration Environment variables: PORT | Default: 8000 DATABASE_URL | Format: postgres://user:password@host:port/database AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION AWS_BUCKET_NAME Dotenv: Dotenv is used which can load environment variables from a .env file into process.env Example: PORT=8080 DependenciesRefer to application package and dependency trackers for additional dependency information: Infrastructure: Runtime: Node.js &gt;= 6.9.x Engine: NPM &gt;= 3.10.x Database: PostgreSQL &gt;= 9.6.x Storage: AWS S3 Application package: package.json npm-shrinkwrap.json Dependency trackers: Gemnasium VersionEye Bithound Point of Contact and NotificationsYou can report issues and submit questions by opening a new Issue in GitHub. You can Watch this repo to receive notifications from GitHub when a new issue is posted, when an existing issue’s status is updated, and when a pull request is created. ContributingSee CONTRIBUTING for additional information. Public DomainThis project is in the worldwide public domain. As stated in CONTRIBUTING: This project is in the public domain within the United States, and copyright and related rights in the work worldwide are waived through the CC0 1.0 Universal public domain dedication. All contributions to this project will be released under the CC0 dedication. By submitting a pull request, you are agreeing to comply with this waiver of copyright interest. × Search results Close Documentation generated by JSDoc 3.4.3 on April 10, 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
